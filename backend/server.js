const express=require('express');const multer=require('multer');const crypto=require('crypto');
const cors=require('cors');const helmet=require('helmet');const rateLimit=require('express-rate-limit');
const morgan=require('morgan');const fs=require('fs');const path=require('path');const {MongoClient}=require('mongodb');
const app=express();app.use(helmet());app.use(morgan('dev'));app.use(express.json());app.use(cors({origin:true}));
app.use(rateLimit({windowMs:60*1000,max:120}));const upload=multer({dest:path.join(__dirname,'uploads/')});
const MONGO_URI=process.env.MONGO_URI||null;let db=null,Blocks=null,Users=null;
async function initDb(){ if(!MONGO_URI) return; const client=new MongoClient(MONGO_URI); await client.connect(); db=client.db(); Blocks=db.collection('blocks'); Users=db.collection('users'); console.log('Mongo connected');}
initDb().catch(e=>console.log('Mongo not connected:',e.message));
const memBlocks=[];
function createBlock(data){ const prevHash = memBlocks.length ? memBlocks[memBlocks.length-1].hash : '0'.repeat(64); const timestamp=Date.now(); const payload=JSON.stringify({data,timestamp,prevHash}); const hash=crypto.createHash('sha256').update(payload).digest('hex'); const block={id:crypto.randomBytes(8).toString('hex'),timestamp,data,prevHash,hash}; return block; }
app.post('/api/hash-file', upload.single('file'), async (req,res)=>{ try{ if(!req.file) return res.status(400).json({error:'No file'}); const filePath=req.file.path; const buf=fs.readFileSync(filePath); const hash=crypto.createHash('sha256').update(buf).digest('hex'); const block=createBlock({type:'file',filename:req.file.originalname,hash}); if(Blocks) await Blocks.insertOne(block); else memBlocks.push(block); fs.unlinkSync(filePath); res.json({hash,block}); }catch(e){console.error(e); res.status(500).json({error:'Server'});} });
app.post('/api/scan-url', async (req,res)=>{ try{ const {url}=req.body||{}; if(!url) return res.status(400).json({error:'no url'}); const lower=url.toLowerCase(); const suspiciousKeywords=['login','verify','update','secure','bank','confirm']; let score=0; suspiciousKeywords.forEach(k=>{ if(lower.includes(k)) score+=1; }); const isIp=/^https?:\/\/(?:\d{1,3}\.){3}\d{1,3}/.test(lower)?1:0; if(isIp) score+=1; const result={url,suspicious:score>0,score,reason:score>0?'heuristic':'clean'}; const block=createBlock({type:'url-scan',url,result}); if(Blocks) await Blocks.insertOne(block); else memBlocks.push(block); res.json({result,block}); }catch(e){console.error(e); res.status(500).json({error:'Server'});} });
app.post('/api/simulate', async (req,res)=>{ try{ const {payload}=req.body||{}; const block=createBlock({type:'sim',payload:payload||'sample'}); if(Blocks) await Blocks.insertOne(block); else memBlocks.push(block); res.json({block}); }catch(e){console.error(e); res.status(500).json({error:'Server'});} });
app.get('/api/blocks', async (req,res)=>{ try{ if(Blocks){ const list=await Blocks.find().sort({timestamp:-1}).limit(100).toArray(); return res.json({blocks:list}); } else return res.json({blocks:memBlocks.slice().reverse()}); }catch(e){console.error(e); res.status(500).json({error:'Server'});} });
app.post('/api/register', async (req,res)=>{ try{ const {name,email,password}=req.body||{}; if(!email||!password) return res.status(400).json({error:'missing'}); if(Users){ const ex=await Users.findOne({email}); if(ex) return res.status(400).json({error:'exists'}); const r=await Users.insertOne({name,email,password}); return res.json({ok:true,userId:r.insertedId}); } else return res.json({ok:true,message:'demo mode'}); }catch(e){console.error(e); res.status(500).json({error:'Server'});} });
app.post('/api/login', async (req,res)=>{ try{ const {email,password}=req.body||{}; if(!email||!password) return res.status(400).json({error:'missing'}); if(Users){ const u=await Users.findOne({email,password}); if(!u) return res.status(401).json({error:'invalid'}); return res.json({ok:true,userId:u._id}); } else return res.json({ok:true,message:'demo login'}); }catch(e){console.error(e); res.status(500).json({error:'Server'});} });
const PORT=process.env.PORT||4000; app.listen(PORT,()=>console.log('Server',PORT));